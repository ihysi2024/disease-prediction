**CODE CRITIQUE**

How flexible are the interfaces you were given?
How capable are the views?
How convenient was it to reuse their code?
How cleanly written and well-documented was their code?
If you needed to request changes from them, what were they and why were they needed?

    For the view, the provider interfaces that were adapted into our code
included the IEventFrame, IMainFrame, IGridPanel, and IScheduleFrame.
The providers separated interfaces for both the panels and frames in their view
to further modularize their code and increase flexibility in what different views in the
program can accomplish, while still reducing code duplication through composition of the
panels in their frame class implementations. This roughly mimicked our
view frames of IEventView, IPlannerView, and IScheduleView, so integrating their interfaces to
our code base for the view was relatively straightforward.
    For the event frame view, the provider event frame interface can delegate to an Event Panel
to autofill its contents with a given event's information or close the event panel view. In our
implementation of the Event View, the view allows delegation between the panel and controller to
create an event, modify an event, reset the panel to have empty fields, store the information
provided by the user. It seems that the provider has accounted for this functionality in the
Event Panel class implementation, rather than on a high level interface implementation,
which prevented our code integration from effectively creating, removing, or modifying an event.
To adapt our code more seamlessly, methods such as simulateAddEventButtonClicked and
simulateModifyEventButtonClicked should be included in the interface since they are public and can
still delegate to the controller to enact the command callback design. There are also no error
dialog boxes that can alert the user when they've provided incorrect inputs to the system, which
limits the integrity of the event frame and its functionality.
    For the planner view, the provider grid frame interface and main frame interface allow the user
to interact with the program through mouse clicks, standardize who the current user
of the system is, visualize the planner, visualize the event view, or close the planner or the
event view. These implementations matched the customer planner frame and panels, but their
paintComponent method that draws the events and calendar grids to the screen implements a private
method called addEvent. This method does not consider if an event ends on the next week, and will
visualize the event as though it were occurring on the same week. For example, should an event
last from Friday to Sunday, the event should only be visualized on Friday and Saturday, because
Sunday should be considered a day in the next week. However, in the provider system, all three days
are visualized. Because this is part of a private GUI method, it is also impossible to adapt this
method and adjust it to account for this discrepancy. To modularize this code, the addEvent method
should be accessible through the GridPanel interface. The time component for this system also
utilizes a built-in daysofWeek function from java, which was inconvenient to adapt to, given the day
index that numbers the days of the week from 1-7 Monday - Sunday vs 0-6 Sunday - Saturday.
    For the schedule view, the provider schedule interface heavily imitates their event interface,
and limits the functionality of the view accessible through the interface to be user
click interactions. While this is a valid way of constructing their interfaces given the
addActionListener allows the program to store the user's input, it also hinders the flexibility of
their code and prevents seamless changes to the information that might be stored from the user
(i.e. if another text field was added, for example).
    For the model, the provider interfaces that were adapted to the customer code were the Event,
ICentralSystem, IReadOnlyCentralSystem, ISchedule and IEventTime. All the components of an event
were able to be effectively observed through the adaptation of their event interface,
and two events could be determined to be overlapping, which were the most essential functionalities
needed on the customer end. The ICentralSystem also provides access to all core functionality
needed in the customer code, such as observational methods to view a user's schedule, as well as
the ability to add, create, or modify an event by swapping an original event with its
modified version. This allowed for seamless integration and from the model perspective was very
similar to the customer code system.
